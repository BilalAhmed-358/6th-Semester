{
	"rl-qtable": {
		"prefix": "rl-qtable",
		"body": [
			"import gym",
			"import numpy as np",
			"",
			"env = gym.make('FrozenLake-v1')",
			"",
			"num_episodes = 10000",
			"max_steps_per_episode = 100",
			"learning_rate = 0.8",
			"",
			"discount_factor = 0.95",
			"exploration_rate = 1.0",
			"max_exploration_rate = 1.0",
			"min_exploration_rate = 0.01",
			"exploration_decay_rate = 0.001",
			"",
			"action_size = env.action_space.n",
			"state_size = env.observation_space.n",
			"q_table = np.zeros((state_size, action_size))",
			"",
			"for episode in range(num_episodes):",
			"    state = env.reset()",
			"    done = False",
			"    step = 0",
			"",
			"    for step in range(max_steps_per_episode):",
			"        exploration_rate_threshold = np.random.uniform(0, 1)",
			"        if exploration_rate_threshold > exploration_rate:",
			"            action = np.argmax(q_table[state,:])",
			"        else:",
			"            action = env.action_space.sample()",
			"",
			"        new_state, reward, done, info = env.step(action)",
			"",
			"        # bellman equation",
			"        q_table[state, action] = q_table[state, action] + learning_rate * (reward + discount_factor * np.max(q_table[new_state, :]) - q_table[state, action])",
			"",
			"        state = new_state",
			"        if done == True:",
			"            break",
			"",
			"    exploration_rate = min_exploration_rate + (max_exploration_rate - min_exploration_rate) * np.exp(-exploration_decay_rate*episode)",
			"",
			"print(q_table)"
		],
		"description": "rl"
	},
	"svm": {
		"prefix": "svm",
		"body": [
			"from sklearn import datasets",
			"from sklearn.model_selection import train_test_split",
			"",
			"iris = datasets.load_iris()",
			"X = iris.data",
			"y = iris.target",
			"",
			"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)",
			"from sklearn.preprocessing import StandardScaler",
			"",
			"scaler = StandardScaler()",
			"X_train = scaler.fit_transform(X_train)",
			"X_test = scaler.transform(X_test)",
			"from sklearn.svm import SVC",
			"",
			"svm = SVC(kernel='linear', C=1)",
			"svm.fit(X_train, y_train)",
			"from sklearn.metrics import accuracy_score, classification_report",
			"",
			"y_pred = svm.predict(X_test)",
			"accuracy = accuracy_score(y_test, y_pred)",
			"report = classification_report(y_test, y_pred)",
			"",
			"print(f\"Accuracy: {accuracy}\")",
			"print(\"Classification Report:\")",
			"print(report)",
			""
		],
		"description": "svm"
	},
	"lr": {
		"prefix": "lr",
		"body": [
			"import numpy as np ",
			"import pandas as pd",
			"from sklearn.model_selection import train_test_split",
			"from sklearn.linear_model import LinearRegression",
			"from sklearn.metrics import r2_score",
			"import matplotlib.pyplot as plt",
			"",
			"df = pd.read_csv('kaggle_ads.csv')",
			"df.head()",
			"data.corr()",
			"data.isnull().sum()",
			"",
			"dependent, independent = 'Sales', 'TV'",
			"fig, ax = plt.subplots()",
			"ax.scatter(x=df[dependent], y=df[independent])",
			"",
			"x = df.iloc[:,:-1]",
			"y = df.iloc[:,-1]",
			"x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=0, test_size=0.3)",
			"",
			"lin = LinearRegression()",
			"lin.fit(x_train, y_train)",
			"",
			"y_pred = lin.predict(x_test)",
			"r2_score(y_test, y_pred)",
			"lin.coef_",
			"",
			"fig, ax = plt.subplots()",
			"ax.scatter(x=x[independent], y=x[independent], c=df[dependent])"
		],
		"description": "lr"
	},
	"dt": {
		"prefix": "dt",
		"body": [
			"import pandas as pd",
			"import numpy as np",
			"from sklearn.datasets import load_iris",
			"from sklearn.tree import DecisionTreeClassifier",
			"from sklearn.model_selection import train_test_split",
			"from sklearn.metrics import accuracy_score",
			"",
			"iris = load_iris()",
			"classes = iris.target_names",
			"x = iris.data",
			"y = iris.target",
			"x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=42, test_size=0.2)",
			"",
			"clf = DecisionTreeClassifier(criterion='entropy') # min_samples_split optional",
			"clf.fit(x_train, y_train)",
			"",
			"y_custom_pred = clf.predict([1,2,3,4])",
			"y_train_pred = clf.predict(x_train)",
			"y_test_pred = clf.predict(x_test)",
			"",
			"accuracy_score(y_true=y_train, y_pred=y_train_pred)",
			"accuracy_score(y_true=y_test,  y_pred=y_test_pred)",
			"",
			"from sklearn.metrics import confusion_matrix",
			"cm = confusion_matrix(y_test, y_test_pred)",
			"print('Confusion Matrix:')",
			"print(cm)"
		],
		"description": "dt"
	},
	"knn": {
		"prefix": "knn",
		"body": [
			"import numpy as np",
			"from sklearn.neighbors import KNeighborsClassifier",
			"from sklearn.model_selection import train_test_split",
			"from sklearn.datasets import load_iris",
			"from sklearn.metrics import classification_report, confusion_matrix",
			"",
			"iris = load_iris()",
			"X = iris.data",
			"y = iris.target",
			"x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)",
			"",
			"knn = KNeighborsClassifier(n_neighbors=7)",
			"knn.fit(x_train, y_train)",
			"knn.score(x_test, y_test)",
			"",
			"y_pred = knn.predict(X_test)",
			"confusion_matrix(y_test, y_pred)",
			"classification_report(y_test, y_pred)",
			"error = np.mean(pred_i != y_test)",
			"",
			"x_axis = range(1, 40)",
			"plt.plot(x_axis, [error], marker='o')"
		],
		"description": "dt"
	},
	"kmm": {
		"prefix": "kmm",
		"body": [
			"import numpy as np",
			"from sklearn.model_selection import train_test_split",
			"from sklearn.datasets import load_iris",
			"import numpy as np",
			"from sklearn import datasets",
			"from sklearn.cluster import KMeans",
			"import sklearn.metrics as sm",
			"",
			"iris = load_iris()",
			"X = iris.data",
			"y = iris.target",
			"",
			"kmm = KMeans(n_clusters=3)",
			"kmm.fit(x)",
			"kmm.labels_",
			"kmm.cluster_centers_",
			"",
			"pred_y = np.choose(kmm.labels_, [1, 0, 2]).astype(np.int64)",
			"sm.accuracy_score(pred_y, y)",
			"sm.confusion_matrix(pred_y, y)"
		],
		"description": "kmean"
	},
	"hmm": {
		"prefix": "hmm",
		"body": [
			"import numpy as np",
			"import matplotlib.pyplot as plt",
			"from hmmlearn import hmm",
			"",
			"states = [\"Sunny\", \"Rainy\"]",
			"observations = [\"Dry\", \"Wet\"]",
			"state_probability = np.array([0.6, 0.4])",
			"transition_probability = np.array([[0.7, 0.3], [0.3, 0.7]])",
			"",
			"# observation likelihoods",
			"emission_probability= np.array([[0.9, 0.1], [0.2, 0.8]])",
			"",
			"model = hmm.CategoricalHMM(n_components=len(states))",
			"model.startprob_ = state_probability",
			"model.transmat_ = transition_probability",
			"model.emissionprob_ = emission_probability",
			"",
			"observations_sequence = np.array([0, 1, 0, 1, 0, 0]).reshape(-1, 1)",
			"hidden_states = model.predict(observations_sequence)",
			"print(\"Most likely hidden states:\", hidden_states)",
			"",
			"log_probability, hidden_states = model.decode(observations_sequence,",
			"                                              lengths = len(observations_sequence),",
			"                                              algorithm ='viterbi')"
		],
		"description": "hmm2"
	},
	"bayes-rule": {
		"prefix": "bayes-rule",
		"body": [
			"P1 = 0.3",
			"P2 = 0.2",
			"P3 = 0.5",
			"",
			"P_D_given_P1 = 0.01",
			"P_D_given_P2 = 0.03",
			"P_D_given_P3 = 0.02",
			"",
			"P_D = P_D_given_P1*P1 + P_D_given_P2*P2 + P_D_given_P3*P3",
			"",
			"P_P1_given_D = P_D_given_P1 * P1 / P_D",
			"P_P2_given_D = P_D_given_P2 * P2 / P_D",
			"P_P3_given_D = P_D_given_P3 * P3 / P_D",
			"",
			"if P_P1_given_D > P_P2_given_D and P_P1_given_D > P_P3_given_D:",
			"    print('Plan 1 is most likely responsible')",
			"elif P_P2_given_D > P_P1_given_D and P_P2_given_D > P_P3_given_D:",
			"    print('Plan 2 is most likely responsible')",
			"else:",
			"    print('Plan 3 is most likely responsible')"
		],
		"description": "bayesrule1"
	},
	"n-queen": {
		"prefix": "n-queen",
		"body": [
			"n_size = 4",
			"no_of_diags = 2*n_size-1",
			"",
			"cols = [False for i in range(n_size)]",
			"left_diags = [False for i in range(no_of_diags)]",
			"right_diags = [False for i in range(no_of_diags)]",
			"",
			"def is_valid(row, col):",
			"    return  cols[col] == False and \\",
			"            left_diags[row-col+n_size-1] == False and \\",
			"            right_diags[row+col] == False",
			"",
			"def mark(row, col):",
			"    cols[col] = True",
			"    left_diags[row-col+n_size-1] = True",
			"    right_diags[row+col] = True",
			"",
			"def unmark(row, col):",
			"    cols[col] = False",
			"    left_diags[row-col+n_size-1] = False",
			"    right_diags[row+col] = False",
			"",
			"def solve(row, solution):",
			"    if row == n_size:",
			"        return True",
			"",
			"    for col in range(n_size):",
			"        if is_valid(row, col):",
			"            mark(row,col)",
			"            ",
			"            if solve(row + 1, solution):",
			"              solution.append((row,col))",
			"              return True",
			"            ",
			"            unmark(row,col)",
			"",
			"    return len(solution) == n_size",
			"",
			"cols = [False for i in range(n_size)]",
			"left_diags = [False for i in range(no_of_diags)]",
			"right_diags = [False for i in range(no_of_diags)]",
			"",
			"solution = []",
			"solve(0, solution)",
			"print(solution)"
		],
		"description": "n-queen"
	},
	"crypt-arithmetic": {
		"prefix": "crypt",
		"body": [
			"def isSolvable(words, result):",
			"    mp = [-1]*(26)",
			"    used = [0]*(10)",
			"    Hash = [0]*(26)",
			"    CharAtfront = [0]*(26)",
			"    uniq = ''",
			"",
			"    for word in range(len(words)):",
			"        for i in range(len(words[word])):",
			"            ch = words[word][i]",
			"            Hash[ord(ch) - ord('A')] += pow(10, len(words[word]) - i - 1)",
			"",
			"            if mp[ord(ch) - ord('A')] == -1:",
			"                mp[ord(ch) - ord('A')] = 0",
			"                uniq += str(ch)",
			"                ",
			"            if i == 0 and len(words[word]) > 1:",
			"                CharAtfront[ord(ch) - ord('A')] = 1",
			" ",
			"    for i in range(len(result)):",
			"        ch = result[i]",
			"        Hash[ord(ch) - ord('A')] -= pow(10, len(result) - i - 1)",
			" ",
			"        if mp[ord(ch) - ord('A')] == -1:",
			"            mp[ord(ch) - ord('A')] = 0",
			"            uniq += str(ch)",
			"",
			"        if i == 0 and len(result) > 1:",
			"            CharAtfront[ord(ch) - ord('A')] = 1",
			"",
			"    mp = [-1]*(26)",
			"    return True",
			"",
			"def solve(words, i, S, mp, used, Hash, CharAtfront):",
			"    if i == len(words):",
			"        return S == 0",
			" ",
			"    ch = words[i]",
			"    val = mp[ord(words[i]) - ord('A')]",
			" ",
			"    if val != -1:",
			"        return solve(words, i + 1, S + val * Hash[ord(ch) - ord('A')], mp, used, Hash, CharAtfront)",
			" ",
			"    x = False",
			"    for l in range(10):",
			"        if CharAtfront[ord(ch) - ord('A')] == 1 and l == 0:",
			"            continue",
			"        if used[l] == 1:",
			"            continue",
			" ",
			"        mp[ord(ch) - ord('A')] = l",
			"        used[l] = 1",
			"        x |= solve(words, i + 1, S + l * Hash[ord(ch) - ord('A')], mp, used, Hash, CharAtfront)",
			"",
			"        mp[ord(ch) - ord('A')] = -1",
			"        used[l] = 0",
			"    return x",
			" ",
			"arr = [ 'SIX', 'SEVEN', 'SEVEN' ]",
			"S = 'TWENTY'",
			"",
			"if isSolvable(arr, S):",
			"    print('Solution is possible')",
			"else:",
			"    print('Solution is NOT possible')"
		],
		"description": "crypt"
	},
	"alpha-beta": {
		"prefix": "alpha-beta",
		"body": [
			"depthLimit = 3",
			"values = [3, 5, 6, 9, 1, 2, 0, -1]",
			"",
			"import math",
			"",
			"def minimax(depth, nodeIndex, isMaximizing, alpha, beta):",
			"    if depth == depthLimit:",
			"        return values[nodeIndex]",
			"",
			"    if isMaximizing:",
			"        best = -math.inf",
			"        for i in range(0, 2):",
			"            childIndex = nodeIndex * 2 + i",
			"            val = minimax(depth + 1, childIndex, False, alpha, beta)",
			"            best = max(best, val)",
			"            alpha = max(alpha, best)",
			"            if beta <= alpha: break",
			"        return best",
			"",
			"    for i in range(0, 2):",
			"        best = math.inf",
			"        childIndex = nodeIndex * 2 + i",
			"        val = minimax(depth + 1, childIndex, True, alpha, beta)",
			"        best = min(best, val)",
			"        beta = min(beta, best)",
			"        if beta <= alpha: break",
			"    return best",
			"",
			"import math",
			"",
			"initialDepth = 0",
			"optimalValue =  minimax(initialDepth, 0, True, -math.inf, math.inf)",
			"print('The optimal value is :', optimalValue)"
		],
		"description": "alpha-beta"
	},
	"tictactoe-minmax": {
		"prefix": "tic-tac-toe",
		"body": [
			"player = 'o'",
			"bot = 'x'",
			"empty = '*'",
			"board = {",
			"    1: empty, 2: empty, 3: empty,",
			"    4: empty, 5: empty, 6: empty,",
			"    7: empty, 8: empty, 9: empty,",
			"}",
			"",
			"def printBoard(board):",
			"    print(board[1] + ' ' + board[2] + ' ' + board[3])",
			"    print(board[4] + ' ' + board[5] + ' ' + board[6])",
			"    print(board[7] + ' ' + board[8] + ' ' + board[9])",
			"    print()",
			"",
			"def checkForWin():",
			"    return (board[1] == board[2] and board[1] == board[3] and board[1] != empty) or \\",
			"           (board[4] == board[5] and board[4] == board[6] and board[4] != empty) or \\",
			"           (board[7] == board[8] and board[7] == board[9] and board[7] != empty) or \\",
			"           (board[1] == board[4] and board[1] == board[7] and board[1] != empty) or \\",
			"           (board[2] == board[5] and board[2] == board[8] and board[2] != empty) or \\",
			"           (board[3] == board[6] and board[3] == board[9] and board[3] != empty) or \\",
			"           (board[1] == board[5] and board[1] == board[9] and board[1] != empty) or \\",
			"           (board[7] == board[5] and board[7] == board[3] and board[7] != empty);",
			"",
			"def checkWhichMarkWon(mark):",
			"    return (board[1] == board[2] and board[1] == board[3] and board[1] == mark) or \\",
			"           (board[4] == board[5] and board[4] == board[6] and board[4] == mark) or \\",
			"           (board[7] == board[8] and board[7] == board[9] and board[7] == mark) or \\",
			"           (board[1] == board[4] and board[1] == board[7] and board[1] == mark) or \\",
			"           (board[2] == board[5] and board[2] == board[8] and board[2] == mark) or \\",
			"           (board[3] == board[6] and board[3] == board[9] and board[3] == mark) or \\",
			"           (board[1] == board[5] and board[1] == board[9] and board[1] == mark) or \\",
			"           (board[7] == board[5] and board[7] == board[3] and board[7] == mark);",
			"",
			"def checkDraw():",
			"    for key in board.keys():",
			"        if board[key] == empty:",
			"            return False",
			"    return True",
			"",
			"import math",
			"",
			"def insertLetter(letter, position):",
			"    if board[position] != empty:",
			"        print('Cannot insert at position', position)",
			"        position = int(input('Enter a valid position : '))",
			"        insertLetter(letter, position)",
			"        return",
			"        ",
			"    board[position] = letter",
			"    printBoard(board)",
			"",
			"    if checkDraw():",
			"        print('The match is a draw')",
			"        exit()",
			"",
			"    if checkForWin():",
			"        if letter == bot:",
			"            print('Bot has won the match')",
			"        elif letter == player:",
			"            print('Player has won the match')",
			"        exit()",
			"",
			"def playerMove():",
			"    position = int(input('Enter the position for player : '))",
			"    insertLetter(player, position)",
			"    return",
			"",
			"def compMove():",
			"    bestScore = -math.inf",
			"    bestMove = 0",
			"",
			"    for key in board.keys():",
			"        if (board[key] == empty):",
			"            board[key] = bot",
			"            score = minimax(board, 0, False)",
			"            board[key] = empty",
			"            if (score > bestScore):",
			"                bestScore = score",
			"                bestMove = key",
			"",
			"    insertLetter(bot, bestMove)",
			"",
			"def minimax(board, depth, isMaximizing):",
			"    if checkWhichMarkWon(bot):",
			"        return 1",
			"    elif checkWhichMarkWon(player):",
			"        return -1",
			"    elif checkDraw():",
			"        return 0",
			"",
			"    if isMaximizing:",
			"        bestScore = -math.inf",
			"        for key in board.keys():",
			"            if (board[key] == empty):",
			"                board[key] = bot",
			"                score = minimax(board, depth + 1, False)",
			"                board[key] = empty",
			"                if (score > bestScore):",
			"                    bestScore = score",
			"        return bestScore",
			"",
			"    bestScore = math.inf",
			"    for key in board.keys():",
			"        if (board[key] == empty):",
			"            board[key] = player",
			"            score = minimax(board, depth + 1, True)",
			"            board[key] = empty",
			"            if (score < bestScore):",
			"                bestScore = score",
			"    return bestScore",
			"",
			"printBoard(board)",
			"",
			"global firstComputerMove",
			"firstComputerMove = True",
			"",
			"while not checkForWin():",
			"    compMove()",
			"    playerMove()"
		],
		"description": "tic-tac-toe"
	},
	"sudoku": {
		"prefix": "sudoku",
		"body": [
			"def ConstBoard(board):",
			"    print(\"Current State Of Board : \\n\\n\");",
			"    for i in range (0,9):",
			"        if((i>0) and (i%3)==0):",
			"            print(\"\\n\");",
			"        if(board[i]==0):",
			"            print(\"- \",end=\" \");",
			"        if (board[i]==1):",
			"            print(\"O \",end=\" \");",
			"        if(board[i]==-1):    ",
			"            print(\"X \",end=\" \");",
			"    print(\"\\n\\n\");",
			"",
			"#This function takes the user move as input and make the required changes on the board.",
			"def User1Turn(board):",
			"    pos=input(\"Enter X's position from [1...9]: \");",
			"    pos=int(pos);",
			"    if(board[pos-1]!=0):",
			"        print(\"Wrong Move!!!\");",
			"        exit(0) ;",
			"    board[pos-1]=-1;",
			"",
			"def User2Turn(board):",
			"    pos=input(\"Enter O's position from [1...9]: \");",
			"    pos=int(pos);",
			"    if(board[pos-1]!=0):",
			"        print(\"Wrong Move!!!\");",
			"        exit(0);",
			"    board[pos-1]=1;",
			"",
			"#MinMax function.",
			"def minimax(board,player):",
			"    x=analyzeboard(board);",
			"    if(x!=0):",
			"        return (x*player);",
			"    pos=-1;",
			"    value=-2;",
			"    for i in range(0,9):",
			"        if(board[i]==0):",
			"            board[i]=player;",
			"            score=-minimax(board,(player*-1));",
			"            if(score>value):",
			"                value=score;",
			"                pos=i;",
			"            board[i]=0;",
			"",
			"    if(pos==-1):",
			"        return 0;",
			"    return value;",
			"    ",
			"#This function makes the computer's move using minmax algorithm.",
			"def CompTurn(board):",
			"    pos=-1;",
			"    value=-2;",
			"    for i in range(0,9):",
			"        if(board[i]==0):",
			"            board[i]=1;",
			"            score=-minimax(board, -1);",
			"            board[i]=0;",
			"            if(score>value):",
			"                value=score;",
			"                pos=i;",
			" ",
			"    board[pos]=1;",
			"",
			"",
			"#This function is used to analyze a game.",
			"def analyzeboard(board):",
			"    cb=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];",
			"",
			"    for i in range(0,8):",
			"        if(board[cb[i][0]] != 0 and",
			"           board[cb[i][0]] == board[cb[i][1]] and",
			"           board[cb[i][0]] == board[cb[i][2]]):",
			"            return board[cb[i][2]];",
			"    return 0;",
			"",
			"#Main Function.",
			"def main():",
			"    choice=input(\"Enter 1 for single player, 2 for multiplayer: \");",
			"    choice=int(choice);",
			"    #The broad is considered in the form of a single dimentional array.",
			"    #One player moves 1 and other move -1.",
			"    board=[0,0,0,0,0,0,0,0,0];",
			"    if(choice==1):",
			"        print(\"Computer : O Vs. You : X\");",
			"        player= input(\"Enter to play 1(st) or 2(nd) :\");",
			"        player = int(player);",
			"        for i in range (0,9):",
			"            if(analyzeboard(board)!=0):",
			"                break;",
			"            if((i+player)%2==0):",
			"                CompTurn(board);",
			"            else:",
			"                ConstBoard(board);",
			"                User1Turn(board);",
			"    else:",
			"        for i in range (0,9):",
			"            if(analyzeboard(board)!=0):",
			"                break;",
			"            if((i)%2==0):",
			"                ConstBoard(board);",
			"                User1Turn(board);",
			"            else:",
			"                ConstBoard(board);",
			"                User2Turn(board);",
			"         ",
			"",
			"    x=analyzeboard(board);",
			"    if(x==0):",
			"         ConstBoard(board);",
			"         print(\"Draw!!!\")",
			"    if(x==-1):",
			"         ConstBoard(board);",
			"         print(\"X Wins!!! Y Loose !!!\")",
			"    if(x==1):",
			"         ConstBoard(board);",
			"         print(\"X Loose!!! O Wins !!!!\")",
			"       ",
			"#---------------#",
			"main()"
		],
		"description": "sudoku"
	},
	"graphcolor": {
		"prefix": "graphcolor",
		"body": [
			"from typing import List, Dict",
			"",
			"def graph_coloring(csp: Dict[str, List[str]], colors: List[str]) -> Dict[str, str]:",
			"    \"\"\"",
			"    Solves the graph coloring problem using backtracking search and returns",
			"    a dictionary where each key represents a node and its value represents",
			"    the color assigned to that node.",
			"    \"\"\"",
			"    def backtrack(assignment):",
			"        if len(assignment) == len(csp):",
			"            return assignment",
			"        node = select_unassigned_variable(assignment)",
			"        for color in order_domain_values(node, assignment):",
			"            if is_consistent(node, color, assignment):",
			"                assignment[node] = color",
			"                result = backtrack(assignment)",
			"                if result is not None:",
			"                    return result",
			"                assignment[node] = None",
			"        return None",
			"    ",
			"    def select_unassigned_variable(assignment):",
			"        for node in csp:",
			"            if assignment.get(node) is None:",
			"                return node",
			"    ",
			"    def order_domain_values(node, assignment):",
			"        return colors",
			"    ",
			"    def is_consistent(node, color, assignment):",
			"        for neighbor in csp[node]:",
			"            if neighbor in assignment and assignment[neighbor] == color:",
			"                return False",
			"        return True",
			"    ",
			"    return backtrack({})",
			"",
			"# Example graph",
			"graph = {",
			"    'A': ['B', 'C', 'D'],",
			"    'B': ['A', 'C'],",
			"    'C': ['A', 'B', 'D'],",
			"    'D': ['A', 'C']",
			"}",
			"",
			"# Example color set",
			"colors = ['Red', 'Green', 'Blue']",
			"",
			"# Solve the graph coloring problem",
			"result = graph_coloring(graph, colors)",
			"",
			"# Print the result",
			"print(result)",
			""
		],
		"description": "graphcolor"
	},
	"crossword": {
		"prefix": "crossword",
		"body": [
			"from typing import List, Tuple, Dict",
			"",
			"def crossword_csp(words: List[str], constraints: Dict[Tuple[int, int], str]) -> Dict[Tuple[int, int], List[str]]:",
			"    \"\"\"",
			"    Takes in a list of words and a dictionary of constraints (where each key is a",
			"    cell and its value is the letter that must appear in that cell) and returns a",
			"    dictionary where each key represents a cell and its value represents the domain",
			"    of possible letters for that cell.",
			"    \"\"\"",
			"    csp = {}",
			"    for i in range(len(words)):",
			"        for j in range(len(words[i])):",
			"            if (i, j) in constraints:",
			"                # Cell has a constraint, so its domain is just its constraint value",
			"                csp[(i, j)] = [constraints[(i, j)]]",
			"            else:",
			"                # Cell does not have a constraint, so the domain is all possible letters",
			"                domain = []",
			"                for word in words:",
			"                    if len(word) > j and all(word[k] == constraints.get((i, k)) or (i, k) not in constraints for k in range(j)):",
			"                        domain.append(word[j])",
			"                csp[(i, j)] = list(set(domain))",
			"    return csp",
			"",
			"",
			"def solve_crossword(csp: Dict[Tuple[int, int], List[str]]) -> Dict[Tuple[int, int], str]:",
			"    \"\"\"",
			"    Solves the crossword problem using backtracking search and returns a",
			"    dictionary where each key represents a cell and its value represents",
			"    the letter assigned to that cell.",
			"    \"\"\"",
			"    def backtrack(assignment):",
			"        if len(assignment) == len(csp):",
			"            return assignment",
			"        cell = select_unassigned_variable(assignment)",
			"        for value in order_domain_values(cell, assignment):",
			"            if is_consistent(cell, value, assignment):",
			"                assignment[cell] = value",
			"                result = backtrack(assignment)",
			"                if result is not None:",
			"                    return result",
			"                assignment[cell] = None",
			"        return None",
			"    ",
			"    def select_unassigned_variable(assignment):",
			"        for cell in csp:",
			"            if assignment.get(cell) is None:",
			"                return cell",
			"    ",
			"    def order_domain_values(cell, assignment):",
			"        return csp[cell]",
			"    ",
			"    def is_consistent(cell, value, assignment):",
			"        for neighbor in get_neighbors(cell):",
			"            if neighbor in assignment and assignment[neighbor] == value:",
			"                return False",
			"        return True",
			"    ",
			"    def get_neighbors(cell):",
			"        neighbors = []",
			"        i, j = cell",
			"        for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:",
			"            if x >= 0 and x < len(words) and y >= 0 and y < len(words[x]):",
			"                neighbors.append((x, y))",
			"        return neighbors",
			"    ",
			"    return backtrack({})",
			"",
			"",
			"# Example words and constraints",
			"words = ['BAT', 'CAT', 'CUT', 'ACT', 'TIC']",
			"constraints = {(0, 0): 'B', (0, 1): None, (0, 2): None, (1, 0): None, (1, 1): 'A', (1, 2): None, (2, 0): None, (2, 1): None, (2, 2): 'T'}",
			"",
			"# Get the CSP representation of the crossword",
			"csp = crossword_csp(words, constraints)",
			"",
			"# Solve the crossword",
			"result = solve_crossword(csp)",
			"",
			"# Print the result",
			"for i in range(len(words)):",
			"    for j in range(len(words[i])):",
			"        print(f\"Cell ({i}, {j}): {csp[(i, j)]}\")",
			""
		],
		"description": "crossword"
	},
	"latin": {
		"prefix": "latin",
		"body": [
			"from typing import List, Tuple, Dict",
			"",
			"def latin_square_csp(n: int, grid: List[List[int]]) -> Dict[Tuple[int, int], List[int]]:",
			"    \"\"\"",
			"    Takes in an integer n and a partially filled n x n Latin square grid and returns",
			"    a dictionary where each key represents a cell and its value represents the domain",
			"    of possible values for that cell.",
			"    \"\"\"",
			"    csp = {}",
			"    for i in range(n):",
			"        for j in range(n):",
			"            if grid[i][j] == 0:",
			"                # Cell is empty, so the domain is 1-n",
			"                domain = list(range(1, n+1))",
			"                # Remove values that are already in the same row",
			"                domain = [d for d in domain if d not in grid[i]]",
			"                # Remove values that are already in the same column",
			"                domain = [d for d in domain if d not in [grid[x][j] for x in range(n)]]",
			"                # Remove values that are already in the same subgrid",
			"                subgrid_row = (i // int(n**0.5)) * int(n**0.5)",
			"                subgrid_col = (j // int(n**0.5)) * int(n**0.5)",
			"                domain = [d for d in domain if d not in [grid[x][y] for x in range(subgrid_row, subgrid_row+int(n**0.5)) for y in range(subgrid_col, subgrid_col+int(n**0.5))]]",
			"                csp[(i, j)] = domain",
			"            else:",
			"                # Cell is already filled, so its domain is just its value",
			"                csp[(i, j)] = [grid[i][j]]",
			"    return csp",
			"",
			"def solve_latin_square(csp: Dict[Tuple[int, int], List[int]]) -> Dict[Tuple[int, int], int]:",
			"    \"\"\"",
			"    Solves the Latin square problem using backtracking search and returns a",
			"    dictionary where each key represents a cell and its value represents",
			"    the value assigned to that cell.",
			"    \"\"\"",
			"    def backtrack(assignment):",
			"        if len(assignment) == len(csp):",
			"            return assignment",
			"        cell = select_unassigned_variable(assignment)",
			"        for value in order_domain_values(cell, assignment):",
			"            if is_consistent(cell, value, assignment):",
			"                assignment[cell] = value",
			"                result = backtrack(assignment)",
			"                if result is not None:",
			"                    return result",
			"                assignment[cell] = None",
			"        return None",
			"    ",
			"    def select_unassigned_variable(assignment):",
			"        for cell in csp:",
			"            if assignment.get(cell) is None:",
			"                return cell",
			"    ",
			"    def order_domain_values(cell, assignment):",
			"        return csp[cell]",
			"    ",
			"    def is_consistent(cell, value, assignment):",
			"        for neighbor in get_neighbors(cell):",
			"            if neighbor in assignment and assignment[neighbor] == value:",
			"                return False",
			"        return True",
			"    ",
			"    def get_neighbors(cell):",
			"        neighbors = []",
			"        i, j = cell",
			"        # Get neighbors in the same row",
			"        for x in range(n):",
			"            if x != j:",
			"                neighbors.append((i, x))",
			"        # Get neighbors in the same column",
			"        for y in range(n):",
			"            if y != i:",
			"                neighbors.append((y, j))",
			"        # Get neighbors in the same subgrid",
			"        subgrid_row = (i // int(n**0.5)) * int(n**0.5)",
			"        subgrid_col = (j // int(n**0.5)) * int(n**0.5)",
			"        for x in range(subgrid_row, subgrid_row+int(n**0.5)):",
			"        for y in range(subgrid_col, subgrid_col+int(n**0.5)):",
			"            if (x, y) != cell:",
			"                neighbors.append((x, y))",
			"    return neighbors",
			"",
			"return backtrack({})"
		],
		"description": "latin"
	},
	"draw-balls-prob": {
		"prefix": "draw-balls-prob",
		"body": [
			"from itertools import product",
			"",
			"colors = ['white', 'red', 'green']",
			"counts = [10, 20, 30]",
			"",
			"# to calculate probability of drawing n balls given color",
			"def probability(color, n):",
			"    index = colors.index(color)",
			"    ball_count = counts[index]",
			"    total_balls = sum(counts) ",
			"    return ball_count / total_balls ** n",
			"",
			"# to calculate probability of given combinations",
			"def combination_probability(combination):",
			"    result = 1",
			"    for color, count in combination.items():",
			"        result *= probability(color, count)",
			"    return result",
			"",
			"# to generate all possible combinations of n balls",
			"def generate_combinations(n):",
			"    combinations = []",
			"    # all possible counts of white balls",
			"    for num_white in range(n + 1):",
			"        # all possible counts of red balls",
			"        for num_red in range(n - num_white + 1):",
			"            # count of green balls",
			"            num_green = n - num_white - num_red",
			"            combination = {'white': num_white, 'red': num_red, 'green': num_green}",
			"            combinations.append(combination)",
			"    return combinations",
			"",
			"prob_3_white_or_2_red = 0",
			"for combination in generate_combinations(5):",
			"    if combination.get('white', 0) == 3 or combination.get('red', 0) == 2:",
			"        prob_3_white_or_2_red += combination_probability(combination)",
			"",
			"print('Probability of drawing 3 white balls or 2 red balls:', prob_3_white_or_2_red)",
			"",
			"prob_all_same_color = 0",
			"for color in colors:",
			"    prob_all_same_color += combination_probability({color: 5})",
			"",
			"print('Probability of drawing all 5 balls of the same color:', prob_all_same_color)"
		],
		"description": "draw-balls-prob"
	}
}